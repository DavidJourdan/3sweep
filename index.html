<!-- Doctype HTML5 -->
<!doctype html>
<html>
	<head>
		<meta charset=utf-8>
		<!-- Instruct Internet Explorer to use its latest rendering engine -->
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>3-Sweep</title>
		<!-- Meta Description -->
		<meta name="description" content="3-sweep implementation in javascript">
		<style>
			body { 
				margin: 0px;
				overflow: hidden;
			}
			canvas { 
				width: 100%; 
				height: 100%;
				position: absolute;
			}

			#info {
				position: absolute;
				padding: 10px;
				width: 100%;
				text-align: center;
				color: black;
			}
			a { color: mediumaquamarine; }
		</style>

	</head>
	<body>
		<div id="info">
			3 sweep, web version <br />
			Built using <a href="http://threejs.org"> three.js </a> 
		</div>


		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src='lib/dat.gui.min.js'></script>
		<script src="js/Shape.js"></script>
		<script src="js/Parallelepiped.js"></script>
		<script src="js/Cylinder.js"></script>
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, scene, renderer;
			var parameters;
			var nbSelecPts = 0;
			var shape;
			var bitmap = {};

			init();
			render();

			function loadImage(name) {
				var xhr = new XMLHttpRequest();
				xhr.open('GET', name, true);
				xhr.responseType = 'arraybuffer';
				
				xhr.onload = function(e) {
					// response is unsigned 8 bit integer
					var view = new DataView(this.response);
					bitmap.fileheader = {
						bfType: view.getUint16(0, true),
						bfSize: view.getUint32(2, true),
						bfReserved1: view.getUint16(6, true),
						bfReserved2: view.getUint16(8, true),
						bfOffBits: view.getUint32(10, true)
					};
					bitmap.infoheader = {
						biSize: view.getUint32(14, true),
						biWidth: view.getUint32(18, true),
						biHeight: view.getUint32(22, true),
						biPlanes: view.getUint16(26, true),
						biBitCount: view.getUint16(28, true),
						biCompression: view.getUint32(30, true),
						biSizeImage: view.getUint32(34, true),
						biXPxPerMeter: view.getUint32(38, true),
						biYPxPerMeter: view.getUint32(42, true),
						biClrUsed: view.getUint32(46, true),
						biClrImportant: view.getUint32(50, true)
					};
					var start = bitmap.fileheader.bfOffBits;  
					var width = bitmap.infoheader.biWidth;
					var height = bitmap.infoheader.biHeight;
					var stride =	Math.floor((bitmap.infoheader.biBitCount * width + 31) / 32) * 4;

					bitmap.pixels = new Array(height);

					for (var x = 0; x < width; x++) {
						bitmap.pixels[x] = new Array(height);
					}
					for (var y = 0; y < height; y++) {
						for (var x = 0; x < width; x++) {
							var rg = view.getUint16(start + 3*x + stride*y, true);
							var b = view.getUint8(start + 3*x + 2 + stride*y, true);
							var hex = b + 256 * rg;
							bitmap.pixels[x][y] = new THREE.Color(hex);
						}
					}

				};
				 
				xhr.send();
				
			}

			function init() {
				var width = window.innerWidth, height = window.innerHeight;

				// set up renderer
				renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setClearColor(0x000000, 0);
				var image = document.getElementById("image");
				document.body.insertBefore( renderer.domElement, image );
				// var image = document.createElement("img");
				// image.setAttribute("src", "images/bottle.jpg");
				// renderer.domElement.appendChild(image);

				// set up camera
				camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);

				// GUI
				parameters = {
					straightAxis: true,
					tube: function() {
						var curve = new TubeCurve(points);
						var geometry = new THREE.TubeGeometry( curve, points.length, radius, 30, false );
						var material = new THREE.MeshStandardMaterial( {color: 0x0077ff});
						var mesh = new THREE.Mesh( geometry, material );
						scene.add( mesh );
					},
					shape: 'Cylinder'
				}
				var gui = new dat.GUI();
				gui.add(parameters, 'straightAxis').name("Straight Axis");
				gui.add(parameters, 'tube').name("Tube");
				gui.add(parameters, 'shape', ['Cylinder', 'Cube', 'Sphere']).name('Shape');

				// light
				var ambientLight = new THREE.AmbientLight( 0x555555 );
				var lights = [];
				lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 0 ].position.set( 0, 200, 0 );
				lights[ 1 ].position.set( 100, 200, 100 );
				lights[ 2 ].position.set( - 100, - 200, - 100 );

				// scene
				scene = new THREE.Scene();
				scene.add(camera);
				scene.add( lights[ 0 ] );
				scene.add( lights[ 1 ] );
				scene.add( lights[ 2 ] );
				scene.add(ambientLight);

				// image
				var texture = new THREE.TextureLoader().load( 'images/bottle.jpg' );

				var plane;
				if(texture.image.height < window.innerHeight && texture.image.width < window.innerWidth) {
					plane = new THREE.PlaneGeometry(texture.image.width, texture.image.height);
				} else {
					var aspectRatio = texture.image.width / texture.image.height;
					if(texture.image.height / window.innerHeight < texture.image.width / window.innerWidth) {
						plane = new THREE.PlaneGeometry(window.innerWidth, window.innerWidth / aspectRatio);
					} else plane = new THREE.PlaneGeometry(window.innerHeight * aspectRatio, window.innerHeight);
				}
				var material = new THREE.MeshBasicMaterial( { map: texture } );
				var image = new THREE.Mesh(plane, material);
				image.position.z = -999;
				scene.add(image);
				
				window.addEventListener( 'resize', onWindowResize, false );
				renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
				renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);

				loadImage('images/bottle.bmp');
			}

			function render() {
				requestAnimationFrame( render );

	            renderer.autoClear = false;
	            renderer.clear();
				renderer.render(scene, camera);
			}

			function onWindowResize() {
				camera.left = window.innerWidth / - 2;
				camera.right = window.innerWidth /  2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

				// var img = document.getElementById("image");
				// img.setAttribute("height", window.innerHeight + "");
				// img.setAttribute("width", window.innerWidth + "");
			}

			function onDocumentMouseDown(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;

				switch(nbSelecPts) {
					case 0:
					if(parameters.shape === "Cylinder") 
						shape = new Cylinder(x, y, parameters, scene);
					else if(parameters.shape === "Cube") 
						shape = new Parallelepiped(x, y, parameters, scene);
					scene.add(shape.line);
					nbSelecPts++;
					break;

					case 1:
					nbSelecPts++;
					break;

					case 2:
					if(shape.align(x,y) !== undefined) {
						scene.add(shape.mesh);
						nbSelecPts++;
					}
					break;

					case 3:
					nbSelecPts = 0;
					break;
				}
			}

			function onDocumentMouseMove(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;

				switch(nbSelecPts) {
					case 1:
					shape.line.geometry.vertices[1] = new THREE.Vector3(x, y, -500);
					shape.line.geometry.verticesNeedUpdate = true;
					break;

					case 2:
					shape.trace(x,y, scene);
					break;

					case 3:
					shape.sweep(x,y);
					break;
				}
			}

		</script>

	</body>
</html>
