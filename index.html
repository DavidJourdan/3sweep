<!-- Doctype HTML5 -->
<!doctype html>
<html>
	<head>
		<meta charset=utf-8>
		<!-- Instruct Internet Explorer to use its latest rendering engine -->
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>3-Sweep</title>
		<!-- Meta Description -->
		<meta name="description" content="3-sweep implementation in javascript">
		<style>
			body { 
				margin: 0px;
				background-color: #000000;
				overflow: hidden; 
			}
			canvas { width: 100%; height: 100% }

			#info {
				position: absolute;
				padding: 10px;
				width: 100%;
				text-align: center;
				color: #fff;
			}

			a { color: mediumaquamarine; }
		</style>

	</head>
	<body>
		<div id="info">
			3 sweep, web version <br />
			Built using <a href="http://threejs.org"> three.js </a> 
		</div>

		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src='lib/dat.gui.min.js'></script>
		<script src="lib/DragControls.js"></script>
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, scene, mesh, renderer;
			var geometry, parameters, wireframe;
			var material, standardMaterial, wireMaterial;
			var controls;
			var orthoCamera, backgroundScene;
			var lineMesh;
			var nbSelecPts = 0;
			var points, circleMesh;
			var u;

			init();
			render();

			function loadImage(name) {

			}

			function init() {
				var width = window.innerWidth, height = window.innerHeight;

				// set up renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );

				// set up background
				orthoCamera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);

				var lines = new THREE.Geometry();
				lines.vertices.push(new THREE.Vector3(0, 0, -500));
				lines.vertices.push(new THREE.Vector3(0, 0, 0));
				lines.vertices.push(new THREE.Vector3(0, 0, 0));
				lines.vertices.push(new THREE.Vector3(0, 0, 0));
				lineMesh = new THREE.Line(lines, new THREE.LineBasicMaterial({color: 0x0077ff, linewidth: 3}));
				lineMesh.material.depthTest = false;
				lineMesh.material.depthWrite = false;

				var circle = new THREE.Geometry();
				for (var i = 0; i < 41; i++) {
					circle.vertices.push(new THREE.Vector3(Math.cos(i*Math.PI/20), Math.sin(i*Math.PI/20), 0))
				}
				circleMesh = new THREE.Line(circle, new THREE.LineBasicMaterial({color: 0x0077ff, linewidth: 3}));

				backgroundScene = new THREE.Scene();
				backgroundScene.add( lineMesh );
				backgroundScene.add(circleMesh);
				backgroundScene.add(orthoCamera);

				// GUI
				var gui = new dat.GUI();

				// camera
				camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );

				// light
				var light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				var ambientLight = new THREE.AmbientLight( 0x555555 );

				scene = new THREE.Scene();
				scene.add(camera);
				scene.add(light);
				scene.add(ambientLight);

				window.addEventListener( 'resize', onWindowResize, false );
				renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
				renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
			}

			function render() {
				requestAnimationFrame( render );

	            renderer.autoClear = false;
	            renderer.clear();
				renderer.render(backgroundScene, orthoCamera)
				renderer.render( scene, camera );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				orthoCamera.left = window.innerWidth / - 2;
				orthoCamera.right = window.innerWidth /  2;
				orthoCamera.top = window.innerHeight / 2;
				orthoCamera.bottom = window.innerHeight / - 2;
				orthoCamera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseDown(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;
				// switch(nbSelecPts) {
				// 	case 4:
				// 	nbSelecPts = 0;
				// 	case 0:
				// 	lineMesh.geometry.vertices[0] = (new THREE.Vector3(x, y, -500));
				// 	case 1:
				// 	lineMesh.geometry.vertices[1] = (new THREE.Vector3(x, y, -500));
				// 	case 2:
				// 	lineMesh.geometry.vertices[2] = (new THREE.Vector3(x, y, -500));
				// 	case 3:
				// 	lineMesh.geometry.vertices[3] = (new THREE.Vector3(x, y, -500));
				// 	lineMesh.geometry.verticesNeedUpdate = true;
				// 	nbSelecPts++;
				// }
				switch(nbSelecPts) {
					case 0:
					points = new Array();
					points.push(new THREE.Vector3(x,y,-500));
					circleMesh.position.x = x;
					circleMesh.position.y = y;
					circleMesh.position.z = -500;
					circleMesh.scale.x = 0;
					circleMesh.scale.y = 0;
					nbSelecPts++;
					break;

					case 1:
					points.push(new THREE.Vector3(x,y,-500));


					u = new THREE.Vector3();
					u.subVectors(points[1], points[0]).normalize();

					nbSelecPts++;
					break;

					case 2:
					x -= (points[0].x +points[1].x)/2;
					y -= (points[0].y +points[1].y)/2;

					var pos = new THREE.Vector3(x, y, -1);
					var m = new THREE.Matrix3();
					m.set( u.x, u.y, 0,
					      -u.y, u.x, 0,
					       0, 0, 1 );
					pos.applyMatrix3(m);

					var radius =  points[1].distanceTo(points[0])/2;
					if(Math.abs(pos.x) < radius && Math.abs(pos.y) < radius) {
						var cos = pos.y / Math.sqrt( Math.pow(radius, 2) - Math.pow(pos.x, 2) );
						var cos_2 = Math.sqrt((1 + cos)/2);
						var sin_2 = Math.sqrt((1 - cos)/2);
						var rotation = new THREE.Quaternion(sin_2*u.x, sin_2*u.y, 0, cos_2);
						circleMesh.applyQuaternion(rotation);
						circleMesh.geometry.verticesNeedUpdate = true;
					}
					nbSelecPts++;
					break;
				}
			}

			function onDocumentMouseMove(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;
				// if(nbSelecPts > 0 && nbSelecPts < 4) {
				// 	lineMesh.geometry.vertices[nbSelecPts] = (new THREE.Vector3(x, y, -500));
				// 	lineMesh.geometry.verticesNeedUpdate = true;
				// }
				switch(nbSelecPts) {
					case 1:
					var center = new THREE.Vector3();
					center.copy(points[0]);
					center.x = (center.x + x)/2;
					center.y = (center.y + y)/2;
					var radius = center.distanceTo(points[0]);
					circleMesh.scale.x = circleMesh.scale.y = radius;
					circleMesh.position.x = center.x;
					circleMesh.position.y = center.y;
					break;

					case 2:
					// TODO ellipse follows mouse
					break;

					case 3;

				}
			}

			function orthoToProjec(position, z) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = - position.x * 2 * z * Math.tan(camera.fov*Math.PI/360) / rect.height;
				var y = - position.y * 2 * z * Math.tan(camera.fov*Math.PI/360) / rect.height;
				return new THREE.Vector3(x, y, z);
			}
		</script>

	</body>
</html>
