<!-- Doctype HTML5 -->
<!doctype html>
<html>
	<head>
		<meta charset=utf-8>
		<!-- Instruct Internet Explorer to use its latest rendering engine -->
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>3-Sweep</title>
		<!-- Meta Description -->
		<meta name="description" content="3-sweep implementation in javascript">
		<style>
			body { 
				margin: 0px;
				overflow: hidden; 
				background-image: url('images/cube.jpg');
			}
			canvas { width: 100%; height: 100% }

			#info {
				position: absolute;
				padding: 10px;
				width: 100%;
				text-align: center;
				color: black;	
			}
			a { color: mediumaquamarine; }
		</style>

	</head>
	<body>
		<div id="info">
			3 sweep, web version <br />
			Built using <a href="http://threejs.org"> three.js </a> 
		</div>

		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src='lib/dat.gui.min.js'></script>
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, scene, renderer;
			var geometry, parameters, wireframe;
			var material, standardMaterial, wireMaterial;
			var controls;
			var camera;
			var lineMesh;
			var nbSelecPts = 0;
			var points, circleMesh;
			var u, v, w, rotation;
			var cylinder;
			var parameters;
			var radius;
			var box;

			init();
			render();

			function loadImage(name) {

			}

			function init() {
				var width = window.innerWidth, height = window.innerHeight;

				// set up renderer
				renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setClearColor(0x000000, 0);
				document.body.appendChild( renderer.domElement );

				// set up camera
				camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);

				// lines
				var lines = new THREE.Geometry();
				lines.vertices.push(new THREE.Vector3(0, 0, -500));
				lines.vertices.push(new THREE.Vector3(0, 0, -500));
				lines.vertices.push(new THREE.Vector3(0, 0, -500));
				points = [];
				points.push(new THREE.Vector3(0, 0, -500));
				lineMesh = new THREE.Line(lines, new THREE.LineBasicMaterial({color: 0x0077ff, linewidth: 3}));
				lineMesh.material.depthTest = false;
				lineMesh.material.depthWrite = false;

				// circle
				var circle = new THREE.Geometry();
				for (var i = 0; i < 41; i++) {
					circle.vertices.push(new THREE.Vector3(Math.cos(i*Math.PI/20), Math.sin(i*Math.PI/20), 0))
				}
				circleMesh = new THREE.Line(circle, new THREE.LineBasicMaterial({color: 0x0077ff, linewidth: 3}));

				// cylinder
				var geometry = new THREE.CylinderGeometry(10, 10, 10, 30);
				var material = new THREE.MeshStandardMaterial( {color: 0x0077ff} );
				cylinder = new THREE.Mesh( geometry, material );
				cylinder.rotation.x = Math.PI/2;

				// GUI
				parameters = {
					straightAxis: true,
					tube: function() {
						var curve = new TubeCurve(points);
						var geometry = new THREE.TubeGeometry( curve, points.length, radius, 30, false );
						var material = new THREE.MeshStandardMaterial( {color: 0x0077ff});
						var mesh = new THREE.Mesh( geometry, material );
						scene.add( mesh );
					},
					shape: 'Cylinder'
				}
				var gui = new dat.GUI();
				gui.add(parameters, 'straightAxis').name("Straight Axis");
				gui.add(parameters, 'tube').name("Tube");
				gui.add(parameters, 'shape', ['Cylinder', 'Cube', 'Sphere']).name('Shape');

				// light
				var ambientLight = new THREE.AmbientLight( 0x555555 );
				var lights = [];
				lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 0 ].position.set( 0, 200, 0 );
				lights[ 1 ].position.set( 100, 200, 100 );
				lights[ 2 ].position.set( - 100, - 200, - 100 );
				
				// scene
				scene = new THREE.Scene();
				scene.add(cylinder);
				scene.add( lineMesh );
				scene.add(circleMesh);
				scene.add(camera);
				scene.add( lights[ 0 ] );
				scene.add( lights[ 1 ] );
				scene.add( lights[ 2 ] );
				scene.add(ambientLight);

				window.addEventListener( 'resize', onWindowResize, false );
				renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
				renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
			}

			function render() {
				requestAnimationFrame( render );

	            renderer.autoClear = false;
	            renderer.clear();
				renderer.render(scene, camera);
			}

			function onWindowResize() {
				camera.left = window.innerWidth / - 2;
				camera.right = window.innerWidth /  2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseDown(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;

				switch(nbSelecPts) {
					case 4:
					nbSelecPts = 0;
					case 0:
					lineMesh.geometry.vertices[0] = (new THREE.Vector3(x, y, -500));
					case 1:
					lineMesh.geometry.vertices[1] = (new THREE.Vector3(x, y, -500));
					case 2:
					lineMesh.geometry.vertices[2] = (new THREE.Vector3(x, y, -500));
					lineMesh.geometry.verticesNeedUpdate = true;
				}

				switch(parameters.shape) {
					case 'Cylinder':
					alignCircle(x,y);

					if(parameters.straightAxis) {
						if(nbSelecPts == 3) {
							var radius =  points[1].distanceTo(points[0])/2;

							cylinder.geometry = new THREE.CylinderGeometry(radius, radius, 1, 30);
							var mat = new THREE.Matrix4();
							mat.set(u.x,-u.y, 0, 0,
							        u.y, u.x, 0, 0,
							          0,   0, 1, 0,
							          0,   0, 0, 1 );
							cylinder.applyMatrix(mat);
							cylinder.applyQuaternion(rotation);
							cylinder.geometry.verticesNeedUpdate = true;
						}
					} else {
						if(nbSelecPts == 3) {
							var center = points[2];
							points = [];
							points.push(center);
							points.push(center);
						}
					}
					break;

					case 'Cube':
					alignSquare(x, y);
					points[3] = new THREE.Vector3();
					break;
				}
			}

			function onDocumentMouseMove(event) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = event.clientX - rect.left - rect.width/2;
				var y = rect.top - event.clientY + rect.height/2;

				if(nbSelecPts > 0 && nbSelecPts < 3) {
					lineMesh.geometry.vertices[nbSelecPts] = (new THREE.Vector3(x, y, -500));
					lineMesh.geometry.verticesNeedUpdate = true;
				}
				if(parameters.shape == "Cylinder")
					switch(nbSelecPts) {
						case 1:
						var center = new THREE.Vector3();
						center.copy(points[0]);
						center.x = (center.x + x)/2;
						center.y = (center.y + y)/2;
						var radius = center.distanceTo(points[0]);
						circleMesh.scale.x = circleMesh.scale.y = radius;
						circleMesh.position.x = center.x;
						circleMesh.position.y = center.y;
						break;

						case 2:
						// TODO ellipse follows mouse
						var pos = new THREE.Vector3(x - circleMesh.position.x, y - circleMesh.position.y, 0);
						pos.applyEuler(new THREE.Euler( 0, 0, -circleMesh.rotation.z));
						var radius = circleMesh.scale.x;	
						if(Math.abs(pos.x) < radius && Math.abs(pos.y) < radius) {
							var axis = pos.y/Math.sqrt(1 - pos.x*pos.x/(radius*radius));
							circleMesh.scale.y = axis;
						}
						break;

						case 3:
						if(parameters.straightAxis) {
							traceStraightAxis(x, y);
						} else {
							traceCurvedAxis(x,y);
						}
					}
				if(parameters.shape == "Cube") {
					if(nbSelecPts == 3) {
						var dir = w;

						var t = dir.dot(new THREE.Vector3(x - points[2].x, y - points[2].y, 0));
						dir.multiplyScalar(t);

						points[3].addVectors(dir, points[2]);
						lineMesh.geometry.verticesNeedUpdate = true;

						box.position.addVectors(points[2], points[0]).divideScalar(2);
						dir.multiplyScalar(0.5);
						box.position.add(dir);

						var r = points[2].distanceTo(points[0])/Math.sqrt(2);
						var height = points[2].distanceTo(points[3]);
						box.geometry = new THREE.BoxGeometry( r, r, height );
						
						box.geometry.verticesNeedUpdate = true;
					}
				}
			}

			function TubeCurve(list) {
				THREE.Curve.call( this );
				this.points = list;
				this.size = list.length;
			}
			TubeCurve.prototype = Object.create( THREE.Curve.prototype );
			TubeCurve.prototype.constructor = TubeCurve;

			TubeCurve.prototype.getPoint = function ( t ) {
				var i = Math.round(t*(this.size-1));
				return this.points[i];

			};

			function orthoToProjec(position, z) {
				var rect = renderer.domElement.getBoundingClientRect();
				var x = - position.x * 2 * z * Math.tan(camera.fov*Math.PI/360) / rect.height;
				var y = - position.y * 2 * z * Math.tan(camera.fov*Math.PI/360) / rect.height;
				return new THREE.Vector3(x, y, z);
			}

			function alignCircle(x, y) {
				points = lineMesh.geometry.vertices;
				switch(nbSelecPts) {
					case 0:
					circleMesh.position.x = x;
					circleMesh.position.y = y;
					circleMesh.position.z = -500;
					circleMesh.scale.x = 0;
					circleMesh.scale.y = 0;
					nbSelecPts++;
					break;

					case 1:
					u = new THREE.Vector3();
					u.subVectors(points[1], points[0]).normalize();

					circleMesh.rotation.z = u.angleTo(new THREE.Vector3(1,0,0));

					nbSelecPts++;
					break;

					case 2:
					points[2].addVectors(points[1], points[0]).divideScalar(2);
						
					// place the origin at the center of the cirlce
					x -= points[2].x;
					y -= points[2].y;

					// rotate the axis
					var pos = new THREE.Vector3(x, y, -1);
					var m = new THREE.Matrix3();
					m.set( u.x, u.y, 0,
					      -u.y, u.x, 0,
					       0, 0, 1 );
					pos.applyMatrix3(m);

					radius =  points[1].distanceTo(points[0])/2;
					if(Math.abs(pos.x) < radius && Math.abs(pos.y) < radius) {
						var cos = pos.y / Math.sqrt( radius*radius - pos.x*pos.x );
						var cos_2 = Math.sqrt((1 + cos)/2);
						var sin_2 = Math.sqrt((1 - cos)/2);
						rotation = new THREE.Quaternion(sin_2*u.x, sin_2*u.y, 0, cos_2);
						circleMesh.applyQuaternion(rotation);
						circleMesh.geometry.verticesNeedUpdate = true;
						nbSelecPts++;

						v = new THREE.Vector3(-u.y, u.x, 0);
						w = new THREE.Vector3(0, 0, 1);
						u.applyQuaternion(rotation);
						v.applyQuaternion(rotation);
						w.applyQuaternion(rotation);
					}
					break;

					case 3:
					nbSelecPts++;
				}
			}

			function alignSquare(x, y) {
				points = lineMesh.geometry.vertices;
				switch(nbSelecPts) {
					case 0:
					nbSelecPts++;
					break;

					case 1:
					nbSelecPts++;
					break;

					case 2:
					u = new THREE.Vector3();
					u.subVectors(points[0], points[1]);

					v = new THREE.Vector3();
					v.subVectors(points[2], points[1]);

					var u_squared = u.length()*u.length();
					var v_squared = v.length()*v.length();
					var delta = Math.pow(u_squared - v_squared, 2) + 4*u.dot(v)*u.dot(v); //discriminant of the quadratic equation

					var L = ( u_squared + v_squared + Math.sqrt(delta) ) / 2.; //area (size squared) of the square

					points[0].z += Math.sqrt( L - u_squared );
					points[2].z += Math.sqrt( L - v_squared );

					u.z = Math.sqrt( L - u_squared );
					v.z = Math.sqrt( L - v_squared );
					u.normalize();
					v.normalize();
					w = (new THREE.Vector3()).crossVectors(u,v);

					var center = new THREE.Vector3();
					center.addVectors(points[2], points[0]).divideScalar(2);

					var l = Math.sqrt(L);
					var geometry = new THREE.BoxGeometry( l, l, 1 );
					var material = new THREE.MeshStandardMaterial( {color: 0x0077ff} );
					box = new THREE.Mesh( geometry, material );
					box.position.copy(center);

					//first, align an edge of the square with u
					var q = new THREE.Quaternion();
					q.setFromUnitVectors(new THREE.Vector3(0,1,0), u.normalize());

					box.applyQuaternion(q);

					//then, align the other with v
					var q2 = new THREE.Quaternion();
					q2.setFromUnitVectors((new THREE.Vector3(1,0,0)).applyQuaternion(q), v);

					box.applyQuaternion(q2);

					scene.add( box );

					nbSelecPts++;
					break;	

					case 3:
					nbSelecPts++;
				}
			}

			function traceStraightAxis(x, y) {
				var dir = new THREE.Vector3( 0, 0, 1 );
				dir.applyQuaternion(rotation);

				var t = dir.dot(new THREE.Vector3(x - points[2].x, y - points[2].y, 0));
				dir.multiplyScalar(t);

				points[3] = dir.add(points[2]);
				lineMesh.geometry.verticesNeedUpdate = true;

				cylinder.position.addVectors(points[2], points[3]).divideScalar(2);
				var r =  points[1].distanceTo(points[0])/2;
				var height = points[2].distanceTo(points[3]);
				cylinder.geometry = new THREE.CylinderGeometry(r, r, height, 40);
				
				cylinder.geometry.verticesNeedUpdate = true;
			}

			function traceCurvedAxis(x,y) {
				var end = points.length - 1;
				points[end] = new THREE.Vector3(x, y, -500);
				var temp = new THREE.Vector3();
				temp.subVectors(points[0], points[end]);
				var s = v.dot(temp);
				points[end].addScaledVector(v, s);
				var dist = points[end - 1].distanceTo(points[end]);
				if(dist > 5) {
					var lines = new THREE.Geometry();
					lines.vertices = points;
					lineMesh.material = new THREE.LineBasicMaterial({color: 0x0077ff, linewidth: 3});
					lineMesh.geometry = lines;
					lineMesh.geometry.verticesNeedUpdate = true;
					points.push(points[end]);
				}
			}
		</script>

	</body>
</html>
